% \vspace{-0.8em}
\section{The PTA-DTA Problem}
% \vspace{-0.8em}
In this section, we solve the {\sc PTA-DTA} problem through a product construction.
Based on the product construction, we also settle the complexity of the problem.
Below we fix a well-formed PTA $\pta$ in the form (\ref{eq:pta}) and a DTRA (or resp. DTFA) $\dta$ in the form (\ref{eq:tra}) (or resp. (\ref{eq:tfa})).
W.l.o.g, we consider that $\clocks\cap\dtclocks=\emptyset$ and $\alphabet=2^{\ap}$.
%such that $\clocks_1\cap\clocks_2=\emptyset$.
%We also fix a reward structure $(\rcum,\rinst)$ for $\pta$.
%We let $\regions$ be the set of regions w.r.t $\sim_N$, where $N$ is the maximal integer appearing in the clock constraints of $\dta$.

\smallskip
\noindent {\bf The Main Idea.} The core part of the product construction is a PTA which preserves the probability of the set of infinite paths accepted by $\dta$.
The intuition is to let $\dta$ reads external actions of $\pta$ while $\pta$ evolves along the time axis.
The major difficulty is that when $\pta$ performs actions in $\acts$, there is a probabilistic choice between the target locations. Then $\dta$ needs to know the labelling of the target location and the rule (in $\rules$) used for the transition.
A naive solution is to integrate each single rule in $\rules$ into the enabling condition $\enab$ in $\pta$. However, this simple solution does not work since a single rule fixes the labelling of a location in $\pta$, while the probability distribution (given by $\prob$) can jump to locations with different labels.
We solve this difficulty by integrating into the enabling condition
%$\enab$
enough information on clock valuations under $\dta$ so that the rule used for the transition is clear.
%In detail, we introduce two versions of the product construction, each having a computational advantage against the other.

\smallskip
\noindent{\textbf{The Product Construction.}}
For each $\dtloc\in\cstates$, we let
\begin{align*}
&\exttuples_{\dtloc}:=\{h:\alphabet\rightarrow\clcons{\dtclocks}\mid\\
&\qquad
\forall b\in\alphabet.\left(\dtloc, b, h(b), X, \dtloc')\in\rules\mbox{ for some }X, \dtloc'\right)\}\enskip.
\end{align*}
The totality of $\rules$ ensures that $\exttuples_{\dtloc}$ is non-empty.
Intuitively, every element of $\exttuples_{\dtloc}$ is a tuple of clock constraints $\{\phi_b\}_{b\in\alphabet}$, where each
clock constraint $\phi_b$ is chosen from the rules emitting from $\dtloc$ and $b$.
The \emph{product PTA} $\product{\pta}{\dta_q}$ (between $\pta$ and $\dta$ with initial mode $\dtloc$) is defined as
\[
\left({\locs}_\otimes, \loc^*_\otimes, \clocks_\otimes, \acts_\otimes, \inv_\otimes, \enab_\otimes,  \prob_\otimes, \lbfunc_\otimes\right)
\]
where:
\begin{compactitem}
\item $\locs_\otimes:=\locs\times \cstates$;
\item $\loc^*_\otimes:=(\loc^*, q^\star)$ where $q^\star$ is the unique mode such that $\dtatr{(\dtloc,\zero)}{\lbfunc(\loc^*)}{(q^\star,\zero)}$;
    %and ${\left[\zero\right]}_\sim$ is the region which contains the sole element $\zero$;
\item $\clocks_\otimes:=\clocks\cup\dtclocks$;
\item $\acts_\otimes:=\acts\times\bigcup_\dtloc\exttuples_\dtloc$; %$\acts_\otimes:=\acts\times\rules$;
\item $\inv_\otimes(\loc,\dtloc):=\inv(\loc)$ for all $(\loc,\dtloc)\in \locs_\otimes$;
\item $\enab_\otimes\left((\loc,\dtloc), (a,h)\right):=\enab(\loc,a)\wedge \bigwedge_{b\in\alphabet} h(b)$ for all $(\loc,\dtloc)\in \locs_\otimes$ and $h\in \exttuples_\dtloc$, and $\enab_\otimes\left((\loc,\dtloc), (a,h)\right):=\false$ otherwise;
%$\enab_\otimes\left((\loc,\dtloc), (a,r)\right):=\enab(\loc,a)\wedge \phi'$ if $r=\left(\dtloc, b', \phi', Y, \dtloc'\right)$ for some $b', \phi', Y, \dtloc''$, and $\enab_\otimes\left((\loc,\dtloc), (a,r)\right):=\false$ otherwise;
\item
$
    \lbfunc_\otimes \left(
        \loc,\dtloc
    \right)
        := \left \{
            \dtloc
        \right \}
    \mbox{ for all } \left (
        \loc,\dtloc
    \right )
    \in \locs_\otimes;
$
\item $\prob_\otimes$ is given by
\begin{align*}
&\prob_\otimes\left((\loc,\dtloc),(a,h)\right)(Y,(\loc',\dtloc')):=\\
&\quad\begin{cases}
\prob\left(\loc,a\right)(Y\cap \clocks,\loc') & \mbox{if } (\dtloc,\lbfunc\left(\loc'\right), h(\lbfunc\left(\loc'\right)), Y\cap \dtclocks, \dtloc')\\
& \mbox{\quad is a (unique) rule in }\rules\\%\mbox{ and }R'={R}{\left[Y\cap \clocks_2:=0\right]}  \\
0 & \mbox{otherwise}
\end{cases}\enskip.
\end{align*}
\end{compactitem}
Besides standard constructions (e.g., the Cartesian product between $\locs$ and $\cstates$), the product construction also has Cartesian product between $\acts$ and $\bigcup_\dtloc\exttuples_\dtloc$. For each extended action $(a,h)$, the enabling condition for this action is the conjunction between $\enab(\loc,a)$ and all clock constraints from $h$.
This is to ensure that when the action $(a,h)$ is taken, the clock valuation under $\dta$ satisfies every clock constraint in $h$.
Then in the definition for $\prob_\otimes$, upon the action $(a,h)$ and the target location $\loc'$, the product PTA first chooses the unique rule $(\dtloc,\lbfunc\left(\loc'\right), h(\lbfunc\left(\loc'\right)), Y\cap \dtclocks, \dtloc')$ from the emitting mode $\dtloc$ and the label $\lbfunc\left(\loc'\right)$ for which the uniqueness comes from the determinism of $\rules$, then perform probabilistic jump from $\pta$ and the discrete transition from $\dta$.
Finally, we label each $(\loc,\dtloc)$ by $\dtloc$ to meet the Rabin or finite acceptance condition.

\begin{remark}
The novelty for our product construction is that by adopting extended actions and integrating them into enabling condition and probabilistic transition function, the DTA $\dta$ can know which rule to use upon any symbol to be read. This solves the problem that probabilistic jumps can lead to different locations.
\end{remark}

\begin{remark}
It is easy to see that the PTA $\product{\pta}{\dta_q}$ is well-formed as $\pta$ is well-formed and $\dta$ does not introduce extra invariant conditions.
\end{remark}

\begin{figure}
    \centering
    \resizebox{.5\textwidth}{!}{
        \input{example_product}
        }
    \caption{A Part of Product PTA}
    \label{fig:product}
\end{figure}

\begin{example}
Here we represent an running example to show how our product construction works.
Here for the accepting mod $\Q$ in DTA, we have
\begin{align*}
    &
    \exttuples_{\dtloc}
        = \{
            % \\
            % &
            h_0 = \left \{
                \emptyset           \mapsto \true,
                \{ \alpha \}        \mapsto ( x \le 500 ),
                \{ \beta  \}        \mapsto ( y \le 300 ),
                \{ \alpha, \beta \}  \mapsto \true
            \right \},
            \\
            &
            h_1 = \left \{
                \emptyset           \mapsto \true,
                \{ \alpha \}        \mapsto ( x \le 500 ),
                \{ \beta  \}        \mapsto ( 300 < y ),
                \{ \alpha, \beta \}  \mapsto \true
            \right \},
            \\
            &
            h_2 = \left \{
                \emptyset           \mapsto \true,
                \{ \alpha \}        \mapsto ( 500 < x  ),
                \{ \beta  \}        \mapsto ( y \le 300 ),
                \{ \alpha, \beta \}  \mapsto \true
            \right \},
            \\
            &
            h_3 = \left \{
                \emptyset           \mapsto \true,
                \{ \alpha \}        \mapsto ( 500 < x ),
                \{ \beta  \}        \mapsto ( 300 < y ),
                \{ \alpha, \beta \}  \mapsto \true
            \right \}
        \} .
\end{align*}
And a part of the product of Example~\ref{ex:pta} and Example~\ref{ex:dta} is depicted in Figure~\ref{fig:dta}.
\end{example}


% \vspace{-0.8em}

% \vspace{-0.8em}
%$\prob_\otimes$ satisfies that for any $\loc,\loc''\in\locs$, $\dtloc,\dtloc''\in\cstates$, $a\in\acts$, $r=\left(\dtloc, \lbfunc(\loc''), \phi', Y, \dtloc'\right)\in\rules$, $(X,\loc')\in 2^{\clocks_1}\times \locs$ and $Z\subseteq\clocks$, it holds that
%\[
%\prob_\otimes\left((\loc,\dtloc),(a,r)\right)(Z,(\loc'',\dtloc''))=\begin{cases}
%\prob\left(\loc,a\right)({Z}{\setminus}{Y},\loc'') & \mbox{if } \dtloc''=\dtloc' \\
%0 & \mbox{otherwise}
%\end{cases}\enskip.
%\]

Below we clarify the correspondence between $\pta,\dta$ and $\product{\pta}{\dta_\dtloc}$.
We first show the relationship between paths under $\pta$ and those under $\product{\pta}{\dta_\dtloc}$.
Informally, paths under $\product{\pta}{\dta_\dtloc}$ are just paths under $\pta$ extended with runs of $\dta$.

\smallskip\noindent
{\textbf{Transformation $\pfunc$ for Paths from $\pta$ into $\product{\pta}{\dta_\dtloc}$.}}
The transformation is defined as the function $\pfunc:\fnpaths{\pta}\cup\infpaths{\pta}\rightarrow \fnpaths{\product{\pta}{\dta_\dtloc}}\cup\infpaths{\product{\pta}{\dta_\dtloc}}$
which transform a finite or infinite path under $\pta$ into one under  $\product{\pta}{\dta_\dtloc}$.
For a finite path
$
%\[
\fnpath=(\loc_0,\nu_0)a_0\dots a_{n-1}(\loc_n,\nu_n)
%\]
$
under $\pta$ (note that $(\loc_0,\nu_0)=(\loc^*, \zero)$ by definition),
we define $\pfunc(\fnpath)$ to be the unique finite path
\begin{equation}\label{eq:trho}
\pfunc(\fnpath):=((\loc_0,\dtloc_0),\nu_0\cup\mu_0)a'_0\dots a'_{n-1}((\loc_n,\dtloc_n),\nu_n\cup\mu_n)
\end{equation}
under $\product{\pta}{\dta_\dtloc}$ such that the following conditions (\dag) hold:
\begin{compactitem}
\item $\dtatr{(\dtloc,\zero)}{\lbfunc(\loc^*)}{(q_0,\mu_0)}$ (note that $\mu_0=\zero$);
\item for all $0\le k< n$, if $a_k\in [0,\infty)$ then $a'_k=a_k$ and $\dtatr{(\dtloc_k,\mu_k)}{a_k}{\left(\dtloc_{k+1},\mu_{k+1}\right)}$;
\item for all $0\le k< n$, if $a_k\in\acts$ then $a'_k=(a_k,\xi_k)$ and $\dtatr{(\dtloc_k,\mu_k)}{\lbfunc(\loc_{k+1})}{\left(\dtloc_{k+1},\mu_{k+1}\right)}$ where $\xi_k$ is the unique function such that for each symbol $b\in\alphabet$, $\xi_k(b)$ is the unique clock constraint appearing in a rule emitting from $q_k$ and with symbol $b$ such that $\mu_k\models\xi_k(b)$.
\end{compactitem}
Likewise, for an infinite path $\infpath=(\loc_0,\nu_0)a_0(\loc_1,\nu_1)a_1\dots$
under $\pta$, we define $\pfunc(\infpath)$ to be the unique infinite path
\begin{equation}\label{eq:trinfpath}
\pfunc(\infpath):=((\loc_0,\dtloc_0),\nu_0\cup\mu_0)a'_0((\loc_1,\dtloc_1),\nu_1\cup\mu_1)a'_1\dots
\end{equation}
under $\product{\pta}{\dta_\dtloc}$ such that the three conditions in (\dag) hold for all $k\in\Nset_0$ instead of all $0\le k< n$.

%The following lemma shows that $\pfunc$ is a bijection and preserves zenoness.

\begin{lemma}\label{lemm:pfuncbij}
The function $\pfunc$ is a bijection. Moreover, for any infinite path $\infpath$, $\infpath$ is non-zeno iff $\pfunc(\infpath)$ is non-zeno.
\end{lemma}
\begin{proof}
The first claim follows directly from the determinism and totality of DTAs.
The second claim follows from the fact that $\pfunc$ preserves time elapses in the transformation.
\end{proof}

%between $\fnpaths{\pta,\sigma}\cup\infpaths{\pta,\sigma}$ and $\fnpaths{\product{\pta}{\dta_q},\sfunc\left(\sigma\right)}\cup\infpaths{\product{\pta}{\dta_\dtloc},\sfunc\left(\sigma\right)}$.

Below we also show the correspondence on schedulers before and after the product construction.

\smallskip
\noindent{\textbf{Transformation $\sfunc$ for Schedulers from $\pta$ into $\product{\pta}{\dta_\dtloc}$.}}
We define the function $\sfunc$ from the set of schedulers under $\pta$ into the set of schedulers under $\product{\pta}{\dta_\dtloc}$ as follows: for any scheduler $\sigma$ for $\pta$, $\sfunc(\sigma)$ (for $\product{\pta}{\dta_\dtloc}$) is defined such that for any finite path $\fnpath$ under $\pta$ where $\fnpath=(\loc_0,\nu_0)a_0\dots a_{n-1}(\loc_n,\nu_n)$ and $\pfunc(\rho)$ is given as in (\ref{eq:trho}),
\[
\sfunc(\sigma)(\pfunc(\fnpath)):=
\begin{cases}
\sigma(\fnpath) & \mbox{if }n\mbox{ is even} \\
(\sigma(\fnpath),\lambda(\rho)) & \mbox{if }n\mbox{ is odd}
\end{cases}
\]
where $\lambda(\rho)$ is
the unique function such that for each symbol $b\in\alphabet$, $\lambda(\rho)(b)$ is the clock constraint in the unique rule emitting from $q_k$ and with symbol $b$ such that $\mu_n\models\lambda(\rho)(b)$.
Note that the well-definedness of $\sfunc$ follows from Lemma~\ref{lemm:pfuncbij}.

From Lemma~\ref{lemm:pfuncbij}, the product construction, the determinism and totality of $\rules$, one can prove directly the following lemma.
%\vspace{-0.8em}
\begin{lemma}\label{lemm:sfuncbij}
The function $\sfunc$ is a bijection.
\end{lemma}
%\vspace{-0.8em}
Now we prove the relationship between infinite paths accepted by a DTRA/DTFA before product construction and infinite paths satisfying certain Rabin/reachability condition.
We first consider that $\dta$ is a DTRA in the form (\ref{eq:tra}).

We introduce more notations. 
First, we lift the function $\pfunc$ to all subsets of paths in the standard fashion: for all subsets $A\subseteq \fnpaths{\pta}\cup\infpaths{\pta}$, $\pfunc(A):=\{\pfunc(\omega)\mid \omega\in A\}$.
Then for an infinite path $\infpath=(\loc_0,\nu_0)a_0(\loc_1,\nu_1)a_1\dots$ with $\pfunc(\infpath)$ taking the form
(\ref{eq:trinfpath}), we define 
%%%%%
% \vspace{-0.8em}
%\begin{definition}[Traces]
%Let
%$ \pfunc(\infpath) =
%    ((\loc_0,\dtloc_0),\nu_0\cup\mu_0)
%    a'_0
%    ((\loc_1,\dtloc_1),\nu_1\cup\mu_1)
%    a'_1
%    \dots
%$
% and according to definition
% $Lab((\loc_i,\dtloc_i)） = \left\{ \dtloc_i \right\}$.
% Instead of using $\{ q_0 \}, \{ q_1 \}, \dots $,
the \emph{trace} of $ \pfunc ( \infpath ) $ as an infinite word over $\cstates$ defined by
$\trace{ \pfunc ( \infpath ) } := \dtloc_0 \dtloc_1 \dots $ .
Finally, for any scheduler $\sigma$ for $\product{\pta}{\dta_\dtloc}$, 
we define the set $\rabinp{\sigma}$ by
%\end{definition}
%%%%%
% \vspace{-0.8em}
% \begin{proposition}\label{prop:psfunc} $\pfunc\left(\acc{\pta,\sigma}{\dta,\dtloc,F}\right)=\omgpaths{\product{\pta}{\dta_\dtloc},\sfunc\left(\sigma\right)}{\locs\times F}$ for any scheduler $\sigma$, initial mode $q$ and $F\subseteq \cstates$. %or in Definition~\ref{def:infacc}.
% \end{proposition}
% \begin{proof}
% Directly from the product construction and Definition~\ref{def:fnacc}.\qed
% \end{proof}
%\noindent{\textbf{Verifying Limit Rabin Properties.}}
%Paths in $\product{\pta}{\dta_\dtloc}$ that $\pta$ is accepted by $\dta$ is
% 写成定义在普通的 PTA 上还是乘积上好
% $$
%     \AcceptCxAqsF = \left \{
%         \infpath \in \infpaths{\product{\pta}{\dta_\dtloc},\sigma} \mid
%         \infset{
%             \trace{
%                 \infpath
%             }
%         }
%         \mbox{ is Rabin accepting by } \rabin
%     \right\}
% $$
%\begin{small}
$$
    \rabinp{\sigma}:=\left \{
        \infpath \in \infpaths{\product{\pta}{\dta_\dtloc},\sigma} \mid
        \accept{
            \infset{
                \trace{
                    \infpath
                }
            }
        }   {
            \rabin
        }
    \right\}.
$$
%\end{small}
Intuitively, $\rabinp{\sigma}$ is the set of infinite paths that meet the Rabin condition $\rabin$ from $\dta$. 
%and $\AcceptCxAqsF$ is an limit LT Property \cite[Notation10.121]{DBLP:books/daglib/0020348}.
%
% \vspace{-0.8em}
\begin{proposition}\label{prop:psfunc}
For any scheduler $\sigma$ for $\pta$ and any initial mode $q$ for $\dta$, we have $\TLang = \TAcc.$
\end{proposition}
\begin{proof}
% This proof is trivial.
By definition we have
% $$
%     \LangCsAqF = \left \{
%         \infpath \in \infpaths{\pta,\sigma} \mid
%         \infset{
%             \traj{
%                 \run{\dta}{\iconfig}{\lbfunc(\infpath)}
%             }
%         }
%         \mbox{ is Rabin accepting by } \rabin
%     \right\},
% $$
\begin{small}
$$
    \LangCsAqF = \left \{
        \infpath \in \infpaths{\pta,\sigma} \mid
        \accept{
            \infset{
                \traj{
                    \run{\dta}{\iconfig}{\lbfunc(\infpath)}
                }
            }
        }   {
            \rabin
        }
    \right\},
$$
\end{small}
where
$
    \dtloc^*
        =
            \trfunc \left(
                (\dtloc,\zero),
                \lbfunc (
                    \initloc{\infpath}
            \right)
$.
Let $\infpath = (\loc_0,\nu_0) a_0 (\loc_1,\nu_1) a_1 \dots $ be any infinite path.
And by definition of $\pfunc$ we have
$$
    \pfunc( \infpath ) =
        ((\loc_0,\dtloc_0),\nu_0\cup\mu_0)
        a'_0
        ((\loc_1,\dtloc_1),\nu_1\cup\mu_1)
        a'_1
        \dots
$$
% 我觉得不需要把验证 T（pi) 跟 theta（sigma） 相容 写下来
$$
    \run{\dta}{\iconfig}{\lbfunc(\infpath)}
        = \{(\dtloc_n,\mu_n,\lbfunc(\infpath)_{n})\}_{n\in\Nset_0}.
$$
Then it's obvious that
$$\trace{ \pfunc( \infpath ) }
    = q_0 q_1 \dots
    = \traj{
        \run
            {\dta}{\iconfig}
            {\lbfunc(\infpath)}
    }.
$$
Then we conclude that
$\infset {
    \trace {
        \pfunc( \infpath )
    }
}$
is Rabin accepting by $\rabin$ iff
$
    \infset{
        \traj {
            \run
                {\dta}{\iconfig}
                {\lbfunc(\infpath)}
        }
    }
$
is Rabin accepting by $\rabin$.
\end{proof}

Finally, we demonstrate the relationship between acceptance probabilities before product construction and reachability probabilities after product construction.
We also clarify the probability of zenoness before and after the product construction.

% \vspace{-0.8em}
\begin{theorem}\label{thm:main}
For any scheduler $\sigma$ and initial mode $q$,
\[
    \pr
        {\dtloc}
        {\sigma}
        =
            \probm
                ^{\pta,\sigma}
                \left(
                % \acc{\pta,\sigma}{\dta,q,F}
                    \LangCsAqF
                \right)
        =
            \probm
                ^{\product{\pta}{\dta_\dtloc},\theta(\sigma)}
                \left(
                    % \omgpaths{\product{\pta}{\dta_\dtloc},\theta\left(\sigma\right)}{\locs\times F}
                    \TAcc
                \right)
    ~.
\]
Moreover,
$
    \probm
        ^{\pta,\sigma}
        \left( \{
                \infpath \mid \infpath \mbox{ is zeno}
            \}
        \right)
    =
    \probm
        ^{\product{\pta}{\dta_\dtloc},\theta(\sigma)}
        \left( \{
                \infpath' \mid \infpath' \mbox{ is zeno}
            \}
        \right)
$
\enskip.
\end{theorem}
\vspace{-0.8em}
\begin{proof}
Define the probability measure $\probm'$ by: $\probm'(A)=\probm^{\product{\pta}{\dta_\dtloc},\sfunc\left(\sigma\right)}(\pfunc(A))$ for $A\in\mathcal{F}^{\pta,\sigma}$. We show that $\probm'=\probm^{\pta,\sigma}$. By \cite[Theorem 3.3]{PBMeasure}, it suffices to consider cylinder sets as they form a pi-system (cf. \cite[Page 43]{PBMeasure}).
Let $\fnpath=(\loc_0,\nu_0)a_0\dots a_{n-1}(\loc_n,\nu_n)$ be any finite path under $\pta$.
By definition, we have that
\begin{align*}
    \probm^{\pta,\sigma}(\cyl(\fnpath))
        & =
        \probm^{\product{\pta}{\dta_\dtloc}, \sfunc\left(\sigma\right)}(\cyl(\pfunc(\fnpath)))
        \\
        & =
        \probm^{\product{\pta}{\dta_\dtloc},\sfunc\left(\sigma\right)}(\pfunc(\cyl(\fnpath)))
        \\
        & =
        \probm'(\cyl(\fnpath))\enskip.
\end{align*}
The first equality comes from the fact that both versions of product construction preserves transition probabilities. The second equality is due to $\cyl(\pfunc(\fnpath))= \pfunc(\cyl(\fnpath))$.
The final equality follows from the definition.
Hence $\probm^{\pta,\sigma}=\probm'$.
Then the first claim follows from Proposition~\ref{prop:psfunc} and the second claim follows from Lemma~\ref{lemm:pfuncbij}.
\end{proof}
Note that a side result from Theorem~\ref{thm:main} says that $\sfunc$ preserves time-divergence for schedulers before and after product construction.
From Theorem~\ref{thm:main} and Lemma~\ref{lemm:sfuncbij}, one immediately obtains the following result which transforms the {\sc PTA-DTA} problem into computing reachability probabilities under the product PTA.

% \vspace{-0.8em}
\begin{corollary}{(\cite{DBLP:conf/qest/Sproston11})}\label{crly:opt}
For any initial mode $q$,
% there exists an $\rabin_* \subseteq \locs_\otimes$
% s.t. $\rabin_*$ is a union of several maximal end
% components that satisfy $\rabin$.
\begin{align*}
    \opt_\sigma\pr{\dtloc}{\sigma}
        & =
            \opt_{\sigma'}
            \probm^{\product{\pta}{\dta_\dtloc},\sigma'}\left(
                \Accept
                    {\product{\pta}{\dta_\dtloc},\sigma'}
                    % {\rabin}
            \right)
        % \\
        % & =
        %     \opt_{\sigma''}
        %     \probm^{\product{\pta}{\dta_\dtloc},\sigma''}\left(
        %         \omgpaths
        %             {\product{\pta}{\dta_\dtloc},\sigma''}
        %             {\rabin_*}
        %     \right)
        % \\
        % & =
        %     \opt_{\sigma'''}
        %     \probm^{\product{\pta}{\dta_\dtloc},\sigma'''}\left(
        %         \omgpaths
        %             {\product{\pta}{\dta_\dtloc},\sigma'''}
        %             {\rabin_*}
        %     \right),
\end{align*}
where $\opt$ refers to either $\inf$ (infimum) or $\sup$ (supremum),
$\sigma$ (resp. $\sigma'$) range over all time-divergent schedulers
for $\pta$ (resp. $\product{\pta}{\dta_\dtloc}$).
% where $\opt$ refers to either $\inf$ (infimum) or $\sup$ (supremum),
% $\sigma$ (resp. $\sigma'$) range over all time-divergent schedulers
% for $\pta$ (resp. $\product{\pta}{\dta_\dtloc}$) and $\sigma''$ (resp.
% $\sigma'''$) range over all time-divergent (resp. all time-divergent and
% time-convergent) schedulers for $\product{\pta}{\dta_\dtloc}$. $\rabin_*$ can be
% resolved by an MEC algorithm and $\opt_\sigma\pr{\dtloc,\rabin}{\sigma}$
% can be calculated by a reachability analysis.
\end{corollary}
The way \cite{DBLP:conf/qest/Sproston11} discards time-convergent path
is making a copy of every location in PTA model and enforcing a transition
from the original one to the copy happen when 1 time unit is passed. After
transiting to the copy, A transition back to the original one will immediately
happend with no delay. And we put a label \textit{tick} in copy. We only deal with
paths that satisfy $ \square \Diamond tick $ (i.e. \textit{tick} is satisfied
infinitely many times).

Then an MDP $\Region{\product{\pta}{\dta_\dtloc}}$ is obtained from the enlarged
PTA of $ \product{\pta}{\dta_\dtloc} $ through an region construction.
Then we verify the limit rabin property on $\Region{\product{\pta}{\dta_\dtloc}}$
by using a standard MEC algorithm. First, We find all MECs satisfy the corresponding
property of an Rabin acceptance condition. In order to guarantee time-divergence,
we only pick up MECs with at least one location that has an \textit{tick} label and
let $F_*$ be the union of those MECs. Then, we turn to resolve the probability
reachability to $F_*$.
%
\begin{lemma}{Time Complexity of Verifying Limit Rabin Properties(
    \cite[Theorem 10.127]{DBLP:books/daglib/0020348}
)}\label{lemm:principle}
Let $M$ be a finite MDP and $P$ be a limit LT propery specified by a Rabin condition:
$$
\bigvee_{1 \le i \le n} \left(
    \Diamond \square \lnot H_i
    \land
    \square \Diamond K_i
\right)
$$
Then: the values
$
\opt_\sigma \probm^{M,\sigma} \left(
    s \models P
\right)
$
can be computed in time \\
$
\mathcal{O} \left(
    \mbox{poly} \left(
        \mbox{size} \left(
            M
        \right)
    \right)
    \cdot
    k
\right)
$
where $\opt$ refers to either $\inf$ (infimum) or $\sup$ (supremum).
\end{lemma}

Noting that for  $\product{\pta}{\dta_\dtloc}$,
although the upper bound of $| \acts_\otimes |$ is
$ | \acts | \cdot | \cstates| \cdot | \rules |^{ | \alphabet | }$,
$ | \locs_\otimes | $ is polynomial to $ |\locs| \cdot |\cstates| $, and
$ | \clocks_\otimes | = | \clocks_1 | + | \clocks_2| $.
The size of $ \Region{\product{\pta}{\dta_\dtloc}} $ is exponential to
$ |\locs| \cdot |\cstates| $ while the number of transitions is exponential,
% that the computation of $F_*$ can be done in polynomial time in the size of
% $ \Region{\product{\pta}{\dta_\dtloc}} $,
then $\opt_\sigma\pr{\dtloc}{\sigma}$ can be calculated in exponential time
follows from Lemma~\ref{lemm:principle}.

In \cite{LaroussinieS07}, the authors proved that the reachablity problem for arbitary PTAs is \emph{EXPTIME}-complete. Reduction from the PTA reachibility problem to the PTA-DTA model-checking problem can be easily constructed as follows.

For an arbitary PTA $\mathcal{C}=(L, l^*, \mathcal{X},Act,inv,enab,prob,\mathcal{L})$ and a set of final locations $L_F\subseteq L$. Let $\mathcal{C}'=(L, l^*, \mathcal{X},Act,inv,enab,prob,\mathcal{L}')$ where
\begin{displaymath}
    \mathcal{L}'(l):L\rightarrow AP\cup\{\mbox{acc}\}=\left\{
    \begin{array}{cc}
        \mathcal{L}(l) & \mbox{ if } l\not\in L_F\\
        \mathcal{L}(l)\cup\{\mbox{acc}\} & l\in L_F
    \end{array}
    \right.
\end{displaymath}
and DTA $\mathcal{A}'=(Q=\{q_0,q_1\},\Sigma=2^{AP\cup\{\mbox{acc\}}},\mathcal{X}=\emptyset,\Delta,\mathcal{F}=\{(\emptyset, \{q_1\}\})$ where
\begin{itemize}
    \item $\forall \sigma\in\Sigma, \mbox{acc}\in \sigma \rightarrow (q_0,\sigma,true, \emptyset,q_1)\in Delta$,
    \item $\forall \sigma\in\Sigma, i=0,1, (q_i,\sigma,true,\emptyset,q_i)\in \Delta$.
\end{itemize}
It's clear that $L_F$ is reachable in $\mathcal{C}$ iff. for $\mathcal{C}'$ and $\mathcal{A}'$, $sup_\sigma \mathfrak{p}_{q_0}^\sigma=1$.

\begin{proposition}
    The PTA-TRA problem is EXPTIME-complete.
\end{proposition}
%
%\vspace{-0.8em}
%
%The reward structure $(\rcum',\rinst')$ for $\pta$ is defined as follows:
%\begin{compactitem}
%\item $\rcum'(\loc,\dtloc):=\rcum(\loc)$ for any $(\loc,\dtloc)\in \locs_\otimes$;
%\item $\rinst'((\loc,\dtloc),(a,h)):=\rinst(\loc,a)$ for any $(\loc,\dtloc)\in \locs_\otimes$ and $(a,h)\in \acts_\otimes$.
%\end{compactitem}
